---
title: "Simulation of the data"
author: "Aryan Sultan"
date: "2023-03-29"
output:
  html_document: default
  pdf_document: default

---


### Data simulation



```{r eval=T, echo=TRUE, message=F}

library(tidyverse)

total_patients <- 2000 # assuming there are 2000 all around the year
patients_per_month <- 2000/12 # patients per month
days_per_month <- 30
arrival_rate <- patients_per_month/days_per_month

# Bed occupation time (in days) for each stroke level

bed_occupation_time <- list(
  very_mild = 1,
  mild = c(3, 7),
  moderate = c(3,14),  # patients sent to rehab center may stay up to 2 weeks in the ward
  severe_nursing = c(3,21),  # patients sent to nursing center may stay up to 3 weeks
  severe = c(1,21) # die
)

# Probability of each stroke level
stroke_level_prob <- c(0.2, 0.2, 0.35, 0.1, 0.15)

# Number of beds in the stroke ward
num_beds <- 25

```

```{r}

# the function below is created to generate the inter-arrival times between the patients.
# the inter arrival follows an exponential distribution hence rexp(), arrival rate is
# defined above

generate_interarrival_times <- function(total_patients, arrival_rate) {
  interarrival_times <- rexp(total_patients, rate = arrival_rate)
  return(interarrival_times)
}

# the function is created to assign patients (from total_patients) randomly a stroke level.
# This assignment is based on the probabilities defined in the stroke_level_prob. 
# To achieve this we use sample()

assign_stroke_levels <- function(total_patients, stroke_level_prob) {
  stroke_levels <- sample(1:length(stroke_level_prob), 
                          size = total_patients, replace = TRUE,
                          prob = stroke_level_prob)
  return(stroke_levels)
}

stroke_levels <- assign_stroke_levels(total_patients, stroke_level_prob)

# if the probability of the severe stroke is really high, say 0.7, 
# then the sample() function would generate random samples of 2000 patients 
# wherein most patients would be assigned the severe stroke level category. 

# Function to generate length of stay for each patient
# this function takes in three arguments each of which has been defined earlier

generate_length_of_stay <- function(total_patients, bed_occupation_time, stroke_levels) {
  length_of_stay <- numeric(total_patients)
  # for every patient in total patients (1000)
  for (i in 1:total_patients) {
    # creating a variable stroke_level that stores the severity of the stroke 
    # (levels/category) of the current (i the) patient in the iteration
    stroke_level <- stroke_levels[i]
    # if the stroke level is 1 (very mild) then set the length of the stay == bed occupation
    # times of the patient with the level 1 stroke. This is done for every patient with level
    # 1 stroke
    if (stroke_level == 1) {
      length_of_stay[i] <- bed_occupation_time[[stroke_level]]
    } else {
      # else if the stroke level is not 1 
      # then set the length of stay of the patient equal to 
      # random number of days between the lower and upper bound of the days 
      # the patient with a certain level of severity would need to stay
      # in the ward
      # sample() is used here to take on random number of days
      # between the lower bound and upper bound of the days
      # [[1]] indicates the lower bound and [[2]] indicates the upper bound
      length_of_stay[i] <- sample(bed_occupation_time[[stroke_level]][1]:bed_occupation_time[[stroke_level]][2], 1)
    }
  }
  
  return(length_of_stay)
}



# Generate length_of_stay for each patient
length_of_stay <- generate_length_of_stay(total_patients, bed_occupation_time, stroke_levels)

# Add number_of_patients and length_of_stay to arrivals_data

interarrival_times <- generate_interarrival_times(total_patients, arrival_rate)

stroke_levels <- assign_stroke_levels(total_patients, stroke_level_prob)

length_of_stay<- generate_length_of_stay(total_patients, bed_occupation_time, stroke_levels)

arrivals_data <- data.frame(interarrival_times, stroke_levels, length_of_stay)


head(arrivals_data)


```



```{r}
set.seed(2023)
stroke_simulation <- function(total_patients, arrival_rate, 
                              bed_occupation_time, stroke_level_prob, 
                              num_beds) {
  
  interarrival_times <- generate_interarrival_times(total_patients, arrival_rate)
  stroke_levels <- assign_stroke_levels(total_patients, stroke_level_prob)
  length_of_stay <- generate_length_of_stay(total_patients, bed_occupation_time, stroke_levels)
  
  # initializing the beds and queue 
  beds <- rep(0, num_beds)
  queue <- list()
  

# interarrival_time is an input parameter for this function, 
# which represents the time between patient arrivals. 
# This variable is based on the generate_interarrival_times function, 
# where we input the total number of patients and arrival rate.

# The pmax function ensures that the bed occupation times do not become negative. 
# A value of 0 in this context means that the bed is available 
# (i.e., the patient has completed their stay, 
# and the bed is now available for other patients).
  
  update_bed_occupation_times <- function(beds, interarrival_time) {
  beds <- pmax(beds - interarrival_time, 0)
  
  # 'beds' is a numeric vector that represents the current remaining 
  # bed occupation time for each bed in the simulation.
  # Each element in this vector corresponds to a bed in the hospital
  # ward. A value of 0 means that the bed is available for use.
  # Subtracting the interarrival_time from each element of 'beds' 
  # updates the remaining bed occupation times, considering the 
  # passage of time between patient arrivals.
  # The pmax function is used to ensure that the resulting bed 
  # occupation times do not become negative, meaning that a 
  # bed with a remaining time less than or equal to the interarrival_time
  # will be considered available (set to 0).
  return(beds)
}
  
  # for every patient in total patients (1000)
  
  for (i in 1:total_patients) {
    
    # update the beds variable with the bed occupation times 
    # of all the patients arriving at the inter-arrival times
    
    beds <- update_bed_occupation_times(beds, interarrival_times[i])
    # creating a new variable available beds to keep track 
    # of the available beds the beds that are available will
    # have the bed occupation time of 0 so in this variable 
    # I store the beds that are available hence which(beds==0)
    
    available_beds <- which(beds == 0)
    
    # here if the length of the available beds vector 
    # is greater than 0 which means that 
    # there is at least one bed with bed occupation times ==0 
    # then assign the first available bed to the patient 
    # by setting this available bed (bed occupation times ==0) 
    # to the length of the stay of the patient 
    # (whatever the severity of that patient might be)
    
    if (length(available_beds) > 0) {
      beds[available_beds[1]] <- length_of_stay[i]
    } else {
      # if there is no bed available then append the queue list
      queue <- append(queue, length_of_stay[i])
    }
  }
  
  return(list(beds = beds, queue = queue, length_of_stay =length_of_stay))
}

stroke_simulation(total_patients = total_patients,arrival_rate = 6, 
                  bed_occupation_time = bed_occupation_time,
                  stroke_level_prob = stroke_level_prob, 
                  num_beds = 25) -> stroke_sim1

stroke_sim1_month <- stroke_simulation(total_patients = patients_per_month, 
                                       arrival_rate = 6,
                                       bed_occupation_time = bed_occupation_time,
                                       stroke_level_prob = stroke_level_prob,
                                       num_beds = 25)


# stroke_sim1 would show the list of the beds remaining occupation times 
# (in number of days the bed would become available.)
# the queue list show the patients in the queue and
# their corresponding occupation times.

# stroke_sim1_month shows the monthly beds, queue, and the length of stay for patients 
```



```{r}

set.seed(2023)
run_simulation <- function(arrival_rate, bed_occupation_time, stroke_level_prob, total_patients, num_simulations) {
  num_bed_range <- seq(20, 40, by = 1)
  
  performance_metrics_list <- lapply(1:num_simulations, function(simulation) {
    lapply(num_bed_range, function(num_beds) {
      stroke_sim_month <- stroke_simulation(total_patients = total_patients,
                                            arrival_rate = arrival_rate,
                                            bed_occupation_time = bed_occupation_time,
                                            stroke_level_prob = stroke_level_prob,
                                            num_beds = num_beds)
      
      occupied_beds_month <- sum(stroke_sim_month$beds > 0)
      total_beds_month <- length(stroke_sim_month$beds)
      utilization_month <- occupied_beds_month / total_beds_month
      
      total_wait_times_month <- sum(unlist(stroke_sim_month$queue))
      num_patients_queue_month <- length(stroke_sim_month$queue)
      avg_wait_times_month <- total_wait_times_month / num_patients_queue_month
      
      average_time_in_queue_month = sum(unlist(stroke_sim_month$queue)) / num_patients_queue_month
      average_queue_length_month = arrival_rate * average_time_in_queue_month
      max_queue_length_month <- length(stroke_sim_month$queue)
      
      proportion_patients_waiting_month <- num_patients_queue_month / total_patients
      percent_patients_waiting_month <- proportion_patients_waiting_month * 100
      
      avg_length_of_stay_month <- (sum(stroke_sim_month$length_of_stay)) / total_patients
      
      performance_metrics_month <- data.frame(num_beds = num_beds,
                                              utilization_per_month = utilization_month,
                                              avg_wait_times_month = avg_wait_times_month,
                                              avg_queue_length_month = average_queue_length_month,
                                              max_queue_length_month = max_queue_length_month,
                                              proportion_patients_waiting_month = proportion_patients_waiting_month,
                                              percent_patients_wait_month = percent_patients_waiting_month,
                                              avg_length_of_stay_month = avg_length_of_stay_month)
      return(performance_metrics_month)
    })
  })
  
  return(performance_metrics_list)
}

results <- run_simulation(arrival_rate = arrival_rate, 
                          bed_occupation_time = bed_occupation_time, 
                          stroke_level_prob = stroke_level_prob, 
                          total_patients = patients_per_month, 
                          num_simulations = 1000)

```


```{r}
summarize_simulation_results <- function(results) {
  all_simulations <- do.call(rbind, lapply(results, do.call, what = rbind))
  
  summary_results <- aggregate(cbind(utilization_per_month, avg_wait_times_month, avg_queue_length_month,
                                     max_queue_length_month, proportion_patients_waiting_month, percent_patients_wait_month,
                                     avg_length_of_stay_month) ~ num_beds,
                                data = all_simulations, FUN = function(x) c(mean = mean(x), sd = sd(x)))
  
  summary_results <- cbind(summary_results[, "num_beds"], as.data.frame(matrix(unlist(summary_results[, -1]), ncol = 14, byrow = FALSE)))
  colnames(summary_results) <- c("num_beds", "utilization_per_month.mean", "utilization_per_month.sd",
                                 "avg_wait_times_month.mean", "avg_wait_times_month.sd",
                                 "avg_queue_length_month.mean", "avg_queue_length_month.sd",
                                 "max_queue_length_month.mean", "max_queue_length_month.sd",
                                 "proportion_patients_waiting_month.mean", "proportion_patients_waiting_month.sd",
                                 "percent_patients_wait_month.mean", "percent_patients_wait_month.sd",
                                 "avg_length_of_stay_month.mean", "avg_length_of_stay_month.sd")
  
  return(summary_results)
}

summary_results <- summarize_simulation_results(results)


library(ggplot2)

# Plot Utilization per Month
utilization_plot <- ggplot(summary_results, aes(x = num_beds, y = utilization_per_month.mean, ymin = utilization_per_month.mean - utilization_per_month.sd, ymax = utilization_per_month.mean + utilization_per_month.sd)) +
  geom_line() +
  geom_errorbar(width = 0.5) +
  labs(title = "Utilization per Month vs. Number of Beds",
       x = "Number of Beds",
       y = "Utilization per Month (mean ± sd)")

# Plot Average Wait Times per Month
avg_wait_times_plot <- ggplot(summary_results, aes(x = num_beds, y = avg_wait_times_month.mean, ymin = avg_wait_times_month.mean - avg_wait_times_month.sd, ymax = avg_wait_times_month.mean + avg_wait_times_month.sd)) +
  geom_line() +
  geom_errorbar(width = 0.5) +
  labs(title = "Average Wait Times per Month vs. Number of Beds",
       x = "Number of Beds",
       y = "Average Wait Times per Month (mean ± sd)")

# Plot Average Queue Length per Month
avg_queue_length_plot <- ggplot(summary_results, aes(x = num_beds, y = avg_queue_length_month.mean, ymin = avg_queue_length_month.mean - avg_queue_length_month.sd, ymax = avg_queue_length_month.mean + avg_queue_length_month.sd)) +
  geom_line() +
  geom_errorbar(width = 0.5) +
  labs(title = "Average Queue Length per Month vs. Number of Beds",
       x = "Number of Beds",
       y = "Average Queue Length per Month (mean ± sd)")

# Plot Max Queue Length per Month
max_queue_length_plot <- ggplot(summary_results, aes(x = num_beds, y = max_queue_length_month.mean, ymin = max_queue_length_month.mean - max_queue_length_month.sd, ymax = max_queue_length_month.mean + max_queue_length_month.sd)) +
  geom_line() +
  geom_errorbar(width = 0.5) +
  labs(title = "Max Queue Length per Month vs. Number of Beds",
       x = "Number of Beds",
       y = "Max Queue Length per Month (mean ± sd)")

# Plot Proportion of Patients Waiting per Month
proportion_patients_waiting_plot <- ggplot(summary_results, aes(x = num_beds, y = proportion_patients_waiting_month.mean, ymin = proportion_patients_waiting_month.mean - proportion_patients_waiting_month.sd, ymax = proportion_patients_waiting_month.mean + proportion_patients_waiting_month.sd)) +
  geom_line() +
  geom_errorbar(width = 0.5) +
  labs(title = "Proportion of Patients Waiting per Month vs. Number of Beds",
       x = "Number of Beds",
       y = "Proportion of Patients Waiting per Month (mean ± sd)")

# Display the plots
print(utilization_plot)
print(avg_wait_times_plot)
print(avg_queue_length_plot)
print(max_queue_length_plot)
print(proportion_patients_waiting_plot)



```

```{r}
# Make sure to install the ggthemes library if you haven't already
# install.packages("ggthemes")

library(ggplot2)
library(ggthemes)

# Custom color palette
custom_palette <- c("mean" = "#1c9099", "std" = "#f03b20")

# Custom line types
custom_line_types <- c("mean" = "solid", "std" = "dashed")

# Custom facet labels
custom_labels <- c("utilization_per_month" = "Utilization per Month",
                   "avg_wait_times_month" = "Avg. Wait Times per Month",
                   "avg_queue_length_month" = "Avg. Queue Length per Month",
                   "max_queue_length_month" = "Max Queue Length per Month",
                   "proportion_patients_waiting_month" = "Proportion of Patients Waiting per Month",
                   "percent_patients_wait_month" = "Percentage of Patients Waiting per Month",
                   "avg_length_of_stay_month" = "Avg. Length of Stay per Month")

# Create the fancy faceted plot

long_summary_results <- tidyr::pivot_longer(summary_results, -num_beds, names_to = c("metric", "stat"), names_sep = "\\.", values_to = "value")

fancy_plot <- ggplot(long_summary_results, aes(x = num_beds, y = value, color = stat, linetype = stat)) +
  geom_line(size = 1.2) +
  facet_wrap(~ metric, scales = "free_y", ncol = 2, labeller = labeller(metric = custom_labels)) +
  labs(title = "Stroke Ward Simulation Performance Metrics",
       x = "Number of Beds",
       y = "Value",
       color = "Statistic",
       linetype = "Statistic") +
  scale_color_manual(values = custom_palette) +
  scale_linetype_manual(values = custom_line_types) +
  theme_tufte() +
  theme(legend.position = "bottom",
        strip.text = element_text(size = 12),
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        legend.text = element_text(size = 10))

print(fancy_plot)


```



































