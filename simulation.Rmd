---
title: "Simulation of the data"
author: "Aryan Sultan"
date: "2023-03-29"
output:
  html_document: default
  pdf_document: default

---


### Data simulation


```{r}

set.seed(2023)
# Parameters

total_patients <- 2000 # assuming there are 2000 all around the year
patients_per_month <- 2000/12 # patients per month
arrival_rate <- total_patients/365.25  # average 6 patients per day

# Bed occupation time (in days) for each stroke level

bed_occupation_time <- list(
  very_mild = 1,
  mild = c(3, 7),
  moderate = c(3,14),  # patients sent to rehab center may stay up to 2 weeks in the ward
  severe_nursing = c(3,21),  # patients sent to nursing center may stay up to 3 weeks
  severe = c(1,21) # die
)

# Probability of each stroke level
stroke_level_prob <- c(0.2, 0.2, 0.35, 0.1, 0.15)


```

```{r}
set.seed(2023)
# the function below is created to generate the inter-arrival times between the patients.
# the inter arrival follows an exponential distribution hence rexp(), arrival rate is
# defined above

generate_interarrival_times <- function(patients_per_month, arrival_rate) {
  interarrival_times <- rexp(patients_per_month, rate = arrival_rate)
  return(interarrival_times)
}

# the function is created to assign patients (from total_patients) randomly a stroke level.
# This assignment is based on the probabilities defined in the stroke_level_prob. 
# To achieve this we use sample()

assign_stroke_levels <- function(patients_per_month, stroke_level_prob) {
  stroke_levels <- sample(1:length(stroke_level_prob), 
                          size = patients_per_month, replace = TRUE,
                          prob = stroke_level_prob)
  return(stroke_levels)
}

stroke_levels <- assign_stroke_levels(patients_per_month, stroke_level_prob)

# if the probability of the severe stroke is really high, say 0.7, 
# then the sample() function would generate random samples of 2000 patients 
# wherein most patients would be assigned the severe stroke level category. 

# Function to generate length of stay for each patient
# this function takes in three arguments each of which has been defined earlier

generate_length_of_stay <- function(patients_per_month, bed_occupation_time, stroke_levels) {
  length_of_stay <- numeric(patients_per_month)
  # for every patient in total patients (1000)
  for (i in 1:patients_per_month) {
    # creating a variable stroke_level that stores the severity of the stroke 
    # (levels/category) of the current (i the) patient in the iteration
    stroke_level <- stroke_levels[i]
    # if the stroke level is 1 (very mild) then set the length of the stay == bed occupation
    # times of the patient with the level 1 stroke. This is done for every patient with level
    # 1 stroke
    if (stroke_level == 1) {
      length_of_stay[i] <- bed_occupation_time[[stroke_level]]
    } else {
      # else if the stroke level is not 1 
      # then set the length of stay of the patient equal to 
      # random number of days between the lower and upper bound of the days 
      # the patient with a certain level of severity would need to stay
      # in the ward
      # sample() is used here to take on random number of days
      # between the lower bound and upper bound of the days
      # [[1]] indicates the lower bound and [[2]] indicates the upper bound
      length_of_stay[i] <- sample(bed_occupation_time[[stroke_level]][1]:bed_occupation_time[[stroke_level]][2], 1)
    }
  }
  
  return(length_of_stay)
}



# Generate length_of_stay for each patient
length_of_stay <- generate_length_of_stay(patients_per_month, bed_occupation_time, stroke_levels)

# Add number_of_patients and length_of_stay to arrivals_data

interarrival_times <- generate_interarrival_times(patients_per_month, arrival_rate)

stroke_levels <- assign_stroke_levels(patients_per_month, stroke_level_prob)

length_of_stay<- generate_length_of_stay(patients_per_month, bed_occupation_time, stroke_levels)

arrivals_data <- data.frame(interarrival_times, stroke_levels, length_of_stay)


head(arrivals_data)


```

```{r}
set.seed(2023)

stroke_simulation <- function(patients_per_month, arrival_rate, 
                              bed_occupation_time, stroke_level_prob, 
                              num_beds) {
  
  interarrival_times <- generate_interarrival_times(patients_per_month, arrival_rate)
  stroke_levels <- assign_stroke_levels(patients_per_month, stroke_level_prob)
  length_of_stay <- generate_length_of_stay(patients_per_month, bed_occupation_time, stroke_levels)
  
  # initializing the beds and queue 
  beds <- rep(0, num_beds)
  queue <- list()
  

# inter-arrival_time is an input parameter for this function, 
# which represents the time between patient arrivals. 
# This variable is based on the generate_interarrival_times function, 
# where we input the total number of patients and arrival rate.

# The pmax function ensures that the bed occupation times do not become negative. 
# A value of 0 in this context means that the bed is available 
# (i.e., the patient has completed their stay, 
# and the bed is now available for other patients).
  
  update_bed_occupation_times <- function(beds, interarrival_time) {
  beds <- pmax(beds - interarrival_time, 0)
  
  # 'beds' is a numeric vector that represents the current remaining 
  # bed occupation time for each bed in the simulation.
  # Each element in this vector corresponds to a bed in the hospital
  # ward. A value of 0 means that the bed is available for use.
  # Subtracting the interarrival_time from each element of 'beds' 
  # updates the remaining bed occupation times, considering the 
  # passage of time between patient arrivals.
  # The pmax function is used to ensure that the resulting bed 
  # occupation times do not become negative, meaning that a 
  # bed with a remaining time less than or equal to the interarrival_time
  # will be considered available (set to 0).
  return(beds)
}
  
  # for every patient in total patients (1000)
  
  for (i in 1:patients_per_month) {
    
    # update the beds variable with the bed occupation times 
    # of all the patients arriving at the inter-arrival times
    
    beds <- update_bed_occupation_times(beds, interarrival_times[i])
    # creating a new variable available beds to keep track 
    # of the available beds the beds that are available will
    # have the bed occupation time of 0 so in this variable 
    # I store the beds that are available hence which(beds==0)
    
    available_beds <- which(beds == 0)
    
    # here if the length of the available beds vector 
    # is greater than 0 which means that 
    # there is at least one bed with bed occupation times ==0 
    # then assign the first available bed to the patient 
    # by setting this available bed (bed occupation times ==0) 
    # to the length of the stay of the patient 
    # (whatever the severity of that patient might be)
    
    if (length(available_beds) > 0) {
      beds[available_beds[1]] <- length_of_stay[i]
    } else {
      # if there is no bed available then append the queue list
      queue <- append(queue, length_of_stay[i])
    }
  }
  
  return(list(beds = beds, queue = queue, length_of_stay =length_of_stay))
}

stroke_sim_50 <- stroke_simulation(patients_per_month= patients_per_month, arrival_rate= arrival_rate, 
                              bed_occupation_time = bed_occupation_time, stroke_level_prob= stroke_level_prob, num_beds= 50)

stroke_sim_40 <- stroke_simulation(patients_per_month= patients_per_month, arrival_rate= arrival_rate, 
                              bed_occupation_time = bed_occupation_time, stroke_level_prob= stroke_level_prob, num_beds= 40)

stroke_sim_30 <- stroke_simulation(patients_per_month= patients_per_month, arrival_rate= arrival_rate, 
                              bed_occupation_time = bed_occupation_time, stroke_level_prob= stroke_level_prob, num_beds= 30)

stroke_sim_20 <- stroke_simulation(patients_per_month= patients_per_month, arrival_rate= arrival_rate, 
                              bed_occupation_time = bed_occupation_time, stroke_level_prob= stroke_level_prob, num_beds= 20)
```

```{r}
set.seed(2023)

compute_performance_metrics <- function(stroke_sim) {
  num_beds <- length(stroke_sim$beds)
  total_patients <- sum(stroke_sim$patients_arrived)
  
  occupied_beds <- sum(stroke_sim$beds > 0)
  utilization <- occupied_beds / num_beds
      
  total_wait_times <- sum(unlist(stroke_sim$queue))
  num_patients_queue <- length(stroke_sim$queue)
  avg_wait_times <- total_wait_times / num_patients_queue
      
  average_time_in_queue = total_wait_times / num_patients_queue
  average_queue_length = sum(stroke_sim$patients_arrived) * average_time_in_queue
  max_queue_length <- length(stroke_sim$queue)
      
  proportion_patients_waiting <- num_patients_queue / total_patients
  percent_patients_waiting <- proportion_patients_waiting * 100
      
  avg_length_of_stay <- (sum(stroke_sim$length_of_stay)) / total_patients
      
  performance_metrics <- data.frame(num_beds = num_beds,
                                    utilization = utilization,
                                    avg_wait_times = avg_wait_times,
                                    avg_queue_length = average_queue_length,
                                    max_queue_length = max_queue_length,
                                    proportion_patients_waiting = proportion_patients_waiting,
                                    percent_patients_waiting = percent_patients_waiting,
                                    avg_length_of_stay = avg_length_of_stay)
  return(performance_metrics)
}

com_per_20 <- compute_performance_metrics(stroke_sim = stroke_sim_20)
com_per_30 <- compute_performance_metrics(stroke_sim = stroke_sim_30)
com_per_40 <- compute_performance_metrics(stroke_sim = stroke_sim_40)
com_per_50 <- compute_performance_metrics(stroke_sim = stroke_sim_50)

```


```{r}
set.seed(2023)

run_simulation <- function(arrival_rate, bed_occupation_time, stroke_level_prob, patients_per_month, num_simulations) {
  num_bed_range <- seq(20, 50, by = 1)

  performance_metrics_list <- lapply(1:num_simulations, function(simulation) {
    lapply(num_bed_range, function(num_beds) {
      stroke_sim <- stroke_simulation(patients_per_month = patients_per_month,
                                            arrival_rate = arrival_rate,
                                            bed_occupation_time = bed_occupation_time,
                                            stroke_level_prob = stroke_level_prob,
                                            num_beds = num_beds)
      performance_metrics_month <- compute_performance_metrics(stroke_sim)
      return(performance_metrics_month)
    })
  })

  return(performance_metrics_list)
}

results <- run_simulation(arrival_rate = arrival_rate, bed_occupation_time = bed_occupation_time, stroke_level_prob = stroke_level_prob, patients_per_month = patients_per_month, num_simulations = 1000)

```


```{r}
library(ggplot2)

# Function for plotting stroke severity distribution
plot_stroke_severity_distribution <- function(stroke_levels, stroke_level_prob) {
  df <- data.frame(stroke_levels = stroke_levels,
                   stroke_level_prob = stroke_level_prob)
  
  ggplot(df, aes(x = stroke_levels, y = stroke_level_prob)) +
    geom_bar(stat = "identity") +
    theme_minimal() +
    labs(title = "Stroke Severity Distribution",
         x = "Stroke Severity Levels",
         y = "Probability")
}

# Plot stroke severity distribution
plot_stroke_severity_distribution(1:length(stroke_level_prob), stroke_level_prob)

# Function for plotting length of stay distribution
plot_length_of_stay_distribution <- function(length_of_stay) {
  ggplot(data.frame(length_of_stay = length_of_stay), aes(length_of_stay)) +
    geom_histogram(binwidth = 1) +
    theme_minimal() +
    labs(title = "Length of Stay Distribution",
         x = "Length of Stay (Days)",
         y = "Number of Patients")
}

# Generate length_of_stay for each patient
length_of_stay <- generate_length_of_stay(patients_per_month, bed_occupation_time, stroke_levels)

# Plot length of stay distribution
plot_length_of_stay_distribution(length_of_stay)

# Function for plotting simulation results
plot_simulation_results <- function(results, bed_counts) {
  avg_wait_times <- sapply(results, function(result) mean(unlist(result$queue)))
  utilization_rates <- sapply(results, function(result) sum(result$beds > 0) / length(result$beds))
  
  df <- data.frame(bed_counts = bed_counts,
                   avg_wait_times = avg_wait_times,
                   utilization_rates = utilization_rates)
  
  ggplot(df, aes(x = bed_counts)) +
    geom_line(aes(y = avg_wait_times, color = "Average Wait Times")) +
    geom_line(aes(y = utilization_rates, color = "Utilization Rates")) +
    theme_minimal() +
    scale_y_continuous(sec.axis = sec_axis(~ ., name = "Utilization Rates")) +
    labs(title = "Simulation Results",
         x = "Bed Counts",
         y = "Average Wait Times",
         color = "Metrics")
}

# Run the simulation with different bed counts
bed_counts <- seq(20, 50)
results <- lapply(bed_counts, function(bed_count) {
  stroke_simulation(patients_per_month, arrival_rate, bed_occupation_time, stroke_level_prob, bed_count)
})

# Plot simulation results
plot_simulation_results(results, bed_counts)

```
THINGS TO IMPROVE IN THE VISUALIZATION: CHANGE THE STROKE SEVERITY LEVELS FROM INDICES TO NAMES


```{r}
# Function for plotting individual performance metrics
plot_individual_performance_metrics <- function(performance_metrics_list) {
  
  # Combine all the simulation results into a single data frame
  combined_results <- do.call(rbind, lapply(performance_metrics_list, function(sim_result) {
    do.call(rbind, sim_result)
  }))
  
  # Calculate the average performance metrics across all simulations
  avg_performance_metrics <- aggregate(. ~ num_beds, data = combined_results, mean)
  
  # Create a list of plots for each performance metric
plots <- lapply(names(avg_performance_metrics)[-1], function(metric_name) {
  p <- ggplot(avg_performance_metrics, aes(x = num_beds, y = !!sym(metric_name))) +
    geom_line() +
    theme_minimal() +
    labs(title = metric_name,
         x = "Number of Beds",
         y = metric_name)
  
  if (metric_name %in% c("max_queue_length_month", "percent_patients_wait_month")) {
    p <- p + scale_y_continuous(breaks = seq(min(avg_performance_metrics[[metric_name]]), 
                                            max(avg_performance_metrics[[metric_name]]), by = 5))
  }
  
  return(p)
})

return(plots)

}


# Run the simulation 100 times
results <- run_simulation( 
                          arrival_rate = arrival_rate, 
                          bed_occupation_time = bed_occupation_time, 
                          stroke_level_prob = stroke_level_prob, 
                          patients_per_month = patients_per_month, 
                          num_simulations = 1000)

# Generate individual plots for each performance metric
individual_plots <- plot_individual_performance_metrics(results)

# Print individual plots
for (plot in individual_plots) {
  print(plot)
}


```

